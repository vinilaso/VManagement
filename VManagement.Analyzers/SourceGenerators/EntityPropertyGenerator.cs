using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;
using VManagement.Analyzers.DTO;
using VManagement.Analyzers.Helpers;
using VManagement.Analyzers.LightJson;

namespace VManagement.Analyzers.SourceGenerators
{
    [Generator]
    public class EntityPropertyGenerator : IIncrementalGenerator
    {
        private const string LogFilePath = @"C:\VManagementV2\Files\analyzer_log.txt";
        private const string MetadataFilePath = @"C:\VManagementV2\Files\entityMetadata.json";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            string jsonContent = File.ReadAllText(MetadataFilePath);
            EntityMetadata[] entityMetadata = CreateDTO(jsonContent);

            var classesProvider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (syntaxNode, _) => syntaxNode is ClassDeclarationSyntax,
                    transform: static (ctx, _) => TransformSyntaxNode(ctx)
                )
                .Where(static classInfo => classInfo is not null)
                .Select(static (classInfo, _) => classInfo!.Value);

            context.RegisterSourceOutput(classesProvider, (spc, classInfo) =>
            {
                Log($"Processando classe: {classInfo.ClassName}, EntityName: {classInfo.EntityName}");

                EntityMetadata? metadata = entityMetadata.FirstOrDefault(m => m.EntityName == classInfo.EntityName);
                Log(metadata is null
                    ? $"Nenhum metadata encontrado para {classInfo.EntityName}"
                    : $"Metadata encontrado para {classInfo.EntityName}");

                File.WriteAllText(classInfo.EntityName, metadata?.ToString() ?? "Metadata null");
                Log($"Arquivo escrito: {classInfo.EntityName}");

                if (metadata is null)
                {
                    Log($"Metadata nulo para {classInfo.EntityName}, retornando sem gerar código");
                    return;
                }

                string autoGeneratedContent = EntityPropertyGeneratorHelper.GetFormattedClass(classInfo, metadata);


                spc.AddSource(
                    hintName: $"{classInfo.ClassName}.g.cs",
                    sourceText: SourceText.From(autoGeneratedContent, Encoding.UTF8)
                );
                Log($"Conteúdo auto-gerado obtido para {classInfo.ClassName}: {SourceText.From(autoGeneratedContent, Encoding.UTF8)}");
                Log($"Arquivo de código fonte adicionado: {classInfo.ClassName}.g.cs");
            });
        }

        private static ClassInfo? TransformSyntaxNode(GeneratorSyntaxContext context)
        {
            Log("Início do método TransformSyntaxNode");

            if (context.Node is not ClassDeclarationSyntax classSyntax)
            {
                Log("Node não é um ClassDeclarationSyntax, retornando default");
                return default;
            }
            Log("Node é um ClassDeclarationSyntax");

            foreach (var attributeList in classSyntax.AttributeLists)
            {
                Log("Iterando sobre attributeList");

                foreach (var attribute in attributeList.Attributes)
                {
                    Log("Iterando sobre attribute");

                    if (attribute is null)
                    {
                        Log("Attribute é null, continuando");
                        continue;
                    }
                    Log("Attribute não é null");

                    var attributeSymbolInfo = context.SemanticModel.GetSymbolInfo(attribute);
                    Log($"Obtido SymbolInfo do attribute: {attributeSymbolInfo.Symbol?.ToDisplayString() ?? "null"}");

                    if (attributeSymbolInfo.Symbol is not ISymbol attributeSymbol)
                    {
                        Log("SymbolInfo.Symbol é null, continuando");
                        continue;
                    }
                    Log($"Symbol encontrado: {attributeSymbol.ToDisplayString()}");

                    if (attributeSymbol.ContainingType.Name == "EntityNameAttribute")
                    {
                        Log("Attribute é EntityNameAttribute");

                        if (context.SemanticModel.GetDeclaredSymbol(classSyntax) is INamedTypeSymbol classSymbol)
                        {
                            Log($"Classe declarada: {classSymbol.ToDisplayString()}");

                            string classNamespace = classSymbol.ContainingNamespace.ToDisplayString();
                            Log($"Namespace da classe: {classNamespace}");

                            string className = classSymbol.Name;
                            Log($"Nome da classe: {className}");

                            string entityName = attribute?.ArgumentList?.Arguments.First().ToString() ?? string.Empty;
                            Log($"Nome da entidade: {entityName}");

                            return new ClassInfo(classNamespace, className, entityName.Replace("\"", string.Empty));
                        }
                        Log("Não foi possível obter o símbolo da classe");
                    }
                    else
                    {
                        Log($"Attribute não é EntityNameAttribute, é: {attributeSymbol.ContainingType.Name}");
                    }
                }
            }

            Log("Nenhum atributo EntityNameAttribute encontrado, retornando default");
            return default;
        }

        //private static ClassInfo TransformSyntaxNode(GeneratorSyntaxContext context)
        //{
        //    if (context.Node is not ClassDeclarationSyntax classSyntax)
        //        return default;

        //    foreach (var attributeList in classSyntax.AttributeLists)
        //    {
        //        foreach (var attribute in attributeList.Attributes)
        //        {
        //            if (attribute is null)
        //                continue;

        //            var attributeSymbolInfo = context.SemanticModel.GetSymbolInfo(attribute);

        //            if (attributeSymbolInfo.Symbol is not ISymbol attributeSymbol)
        //                continue;

        //            if (attributeSymbol.ContainingType.Name == "EntityNameAttribute")
        //            {
        //                if (context.SemanticModel.GetDeclaredSymbol(classSyntax) is INamedTypeSymbol classSymbol)
        //                {
        //                    string
        //                        classNamespace = classSymbol.ContainingNamespace.ToDisplayString(),
        //                        className = classSymbol.Name,
        //                        entityName = attribute?.ArgumentList?.Arguments.First().ToString() ?? string.Empty;

        //                    return new ClassInfo(classNamespace, className, entityName);
        //                }
        //            }
        //        }
        //    }

        //    return default;
        //}

        private static void Log(string mensagem)
        {
            return;
            File.AppendAllText(LogFilePath, "\n" + mensagem);
        }

        private static EntityMetadata[] CreateDTO(AdditionalText file, CancellationToken cancellationToken)
        {
            SourceText? fileText = file.GetText();

            if (fileText is null)
                return [];

            return CreateDTO(fileText.ToString());
        }

        private static EntityMetadata[] CreateDTO(string fileText)
        {
            Log("Início do método CreateDTO");

            try
            {
                Log("Tentando fazer o Parse do JSON");
                JsonValue jsonData = JsonValue.Parse(fileText);
                Log("Parse do JSON concluído");

                JsonArray entityArray = jsonData.AsJsonArray;
                Log($"Array de entidades obtido. Quantidade: {entityArray.Count}");

                EntityMetadata[] result = new EntityMetadata[entityArray.Count];
                Log("Array de resultado criado");

                for (int i = 0; i < entityArray.Count; i++)
                {
                    Log($"Processando entidade de índice {i}");

                    JsonObject entityObject = entityArray[i].AsJsonObject;
                    Log("JsonObject da entidade obtido");

                    EntityMetadata entityMetadata = new() { EntityName = entityObject["entityName"].AsString };
                    Log($"EntityMetadata criado com EntityName: {entityMetadata.EntityName}");

                    JsonArray columnArray = entityObject["columns"].AsJsonArray;
                    Log($"Array de colunas obtido. Quantidade: {columnArray.Count}");

                    entityMetadata.Columns = new EntityColumnMetadata[columnArray.Count];
                    Log("Array de columns dentro da entidade inicializado");

                    for (int j = 0; j < columnArray.Count; j++)
                    {
                        Log($"Processando coluna de índice {j}");

                        JsonObject columnObject = columnArray[j].AsJsonObject;
                        Log("JsonObject da coluna obtido");

                        EntityColumnMetadata columnMetadata = new()
                        {
                            ColumnName = columnObject["columnName"].AsString,
                            ColumnType = columnObject["columnType"].AsString,
                            DotNetPropertyName = columnObject["dotNetPropertyName"].AsString,
                            DotNetPropertyType = columnObject["dotNetPropertyType"].AsString,
                            ConversionMethod = columnObject["conversionMethod"].AsString
                        };
                        Log($"EntityColumnMetadata criado: Nome={columnMetadata.ColumnName}, Tipo={columnMetadata.ColumnType}, Propriedade={columnMetadata.DotNetPropertyName}, TipoDotNet={columnMetadata.DotNetPropertyType}");

                        entityMetadata.Columns[j] = columnMetadata;
                        Log($"Coluna atribuída ao índice {j} da entidade");
                    }

                    result[i] = entityMetadata;
                    Log($"Entidade atribuída ao índice {i} do resultado");
                }

                Log("Fim do processamento das entidades. Retornando resultado");
                return result;
            }
            catch (Exception ex)
            {
                Log($"Exceção ao processar JSON: {ex.Message}");
                return [];
            }
        }
    }
}
